use crate::tui::Response as TuiResponse;
use crate::{ConnectionData, Connections};
use std::net::SocketAddr;
use std::sync::Arc;
use testsuite::Response as bl;
use testsuite::ResponseFormat;
use tokio::sync::Mutex;

use testsuite::Message;
#[derive(Copy, Clone, Debug)]
enum CliEvent<I> {
    Input(I),
    Tick,
}

enum Screen {
    List,
    Details,
}

impl From<Screen> for usize {
    fn from(input: Screen) -> usize {
        match input {
            Screen::List => 0,
            Screen::Details => 1,
        }
    }
}

#[derive(Debug)]
pub struct Response {
    addr: SocketAddr,
    http_response: testsuite::Response,
}

pub async fn handle_message(message: Message, connections: Arc<Mutex<Connections>>) {
    let mut connections = connections.lock().await;
    match message {
        Message::ConnectionFailed => {}
        Message::Response(message) => match connections.get_mut(&message.addr) {
                Some(data) => {
                    let r = TuiResponse {
                        addr: message.addr,
                        http_response: bl {
                            content: Some(message.response.to_string()),
                            format: ResponseFormat::Json,
                        },
                    };
                    data.push(r)
                }
                None => {
                    connections.insert(
                        message.addr,
                        vec![TuiResponse {
                            addr: message.addr,
                            http_response: bl {
                                content: Some(message.response.to_string()),
                                format: ResponseFormat::Json,
                            },
                        }],
                    );
                }
            },
        Message::ConnectionReceived(connection) => match connection {
            Some(connection) => match connections.get_mut(&connection) {
                Some(data) => {
                    let r = TuiResponse {
                        addr: connection,
                        http_response: bl {
                            content: None,
                            format: ResponseFormat::None,
                        },
                    };
                    data.push(r);
                }
                None => {
                    connections.insert(
                        connection,
                        vec![TuiResponse {
                            addr: connection,
                            http_response: bl {
                                content: None,
                                format: ResponseFormat::None,
                            },
                        }],
                    );
                }
            },
            None => {
            }
        },
    }
}

pub struct Tui {
    connections: Arc<Mutex<Connections>>,
}
impl Tui<I> {
    pub async fn render(&self) {
        let a = &self.connections.lock().await;
        println!("{:?}", a.values().len());
    }
    pub fn default(connections: Arc<Mutex<Connections>>) -> Tui {
        Tui { connections }
    }
    pub fn receive(event: CliEvent<I>) {
    }
}
